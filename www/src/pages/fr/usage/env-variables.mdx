---
title: Variables d'environnement
description: D√©buter avec Create T3 App
layout: ../../../layouts/docs.astro
lang: fr
isMdx: true
---

import Callout from "../../../components/docs/callout.tsx";

Create T3 App utilise son propre package [@t3-oss/env-nextjs](https://env.t3.gg), ainsi que [zod](https://zod.dev) en interne pour valider les variables d'environnement √† l'ex√©cution _et_ au moment du build, en fournissant une logique simple dans `src/env.js`.

## env.js

_R√©sum√© : Si vous voulez ajouter une nouvelle variable d'environnement, vous devez ajouter un validateur pour celle-ci dans `src/env.js`, puis ajouter la paire CLEF/VALEUR dans `.env`._

```ts:env.js
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    NODE_ENV: z.enum(["development", "test", "production"]),
  },
  client: {
    // NEXT_PUBLIC_CLIENTVAR: z.string(),
  },
  runtimeEnv: {
    NODE_ENV: process.env.NODE_ENV,
  },
});
```

T3 Env introduit un nouveau concept √† travers la fonction `createEnv`, qui est responsable de la cr√©ation du sch√©ma et inclura la logique de validation principale pour les variables d'environnement c√¥t√© client et c√¥t√© serveur.

<Callout type="info">
  Pour plus d'informations sur le fonctionnement interne de `createEnv`,
  consultez la documentation de [T3 Env](https://env.t3.gg/docs/introduction).
</Callout>

## Utilisation de variables d'environnement

Lorsque vous souhaitez utiliser vos variables d'environnement, vous pouvez les importer depuis `env.js` et les utiliser comme vous le feriez normalement. Si vous l'importez c√¥t√© client et essayez d'acc√©der √† une variable d'environnement du c√¥t√© serveur, vous obtiendrez une erreur d'ex√©cution.

```ts:pages/api/hello.ts
import { env } from "../../env.js";

// `env` is fully typesafe and provides autocompletion
const dbUrl = env.DATABASE_URL;
```

```ts:pages/index.tsx
import { env } from "../env.js";

// ‚ùå This will throw a runtime error
const dbUrl = env.DATABASE_URL;

// ‚úÖ This is fine
const wsKey = env.NEXT_PUBLIC_WS_KEY;
```

## .env.example

Puisque le fichier `.env` par d√©faut n'est pas enregistr√© dans le d√©po√¥t de version, nous avons inclus un fichier `.env.example` dans lequel vous pouvez √©ventuellement conserver une copie de votre fichier `.env` sans les secrets. Cela n'est pas obligatoire, mais nous recommandons de maintenir le fichier exemple √† jour pour faciliter autant que possible le d√©marrage des nouveaux contributeurs avec leur environnement.

Certains frameworks et outils de build, comme Next.js, sugg√®rent de stocker les secrets dans un fichier `.env.local` et de commit les fichiers `.env` dans votre projet. Ceci n'est pas recommand√©, car cela pourrait rendre facile de commit accidentellement des secrets dans votre projet. Au lieu de cela, nous recommandons de stocker les secrets dans le fichier `.env`, de rajouter votre fichier `.env` dans le fichier `.gitignore` et de ne commit que les fichiers `.env.example` dans votre projet.

## Ajout des variables d‚Äôenvironnement

Pour vous assurer que votre build ne se termine jamais sans les variables d'environnement n√©cessaires au projet, vous devriez ajouter de nouvelles variables d'environnement dans **deux** emplacements:

üìÑ `.env`: Entrez votre variable d'environnement comme vous le feriez normalement dans un fichier `.env`, c'est-√†-dire `CLEF=VALEUR`

üìÑ `env.js`: Ajoutez la logique de validation appropri√©e pour les variables d'environnement en d√©finissant un sch√©ma Zod √† l'int√©rieur de `createEnv` pour chacune d'entre elles, par exemple `CLEF: z.string()`. En plus de cela, assurez-vous de la d√©structuration dans l'option `runtimeEnv`, par exemple : `CLEF: process.env.CLEF`

<Callout type="info">
  Pourquoi ai-je besoin de d√©structurer la variable d'environnement dans
  `runtimeEnv` ? Cela est d√ª √† la fa√ßon dont Next.js rassemble les variables
  d'environnement dans certains contextes d'ex√©cution. En les d√©structurant
  manuellement, vous vous assurez que la variable ne sera jamais supprim√©e du
  bundle.
</Callout>

En option, vous pouvez √©galement maintenir √† jour le fichier `.env.example`:

üìÑ `.env.example`: Entrez votre variable d'environnement, mais assurez-vous de ne pas inclure la valeur si elle est secr√®te, c'est-√†-dire `CLEF=VALUE` ou `CLEF=`

### Exemple

_Je veux ajouter le jeton de l‚ÄôAPI Twitter en tant que variable d‚Äôenvironnement c√¥t√© serveur_

1. Ajouter la variable d'environnement dans `.env`:

```
TWITTER_API_TOKEN=1234567890
```

2. Ajouter la variable d'environnement dans `env.js`:

```ts
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    TWITTER_API_TOKEN: z.string(),
  },
  // ...
  runtimeEnv: {
    // ...
    TWITTER_API_TOKEN: process.env.TWITTER_API_TOKEN,
  },
});
```

3. facultatif : ajoutez la variable d'environnement √† `.env.example`, mais n'incluez pas le jeton

```
TWITTER_API_TOKEN=
```

## Coercition de type

Toutes les variables que vous ajoutez √† `.env` seront import√©es en tant que cha√Ænes de caract√®res, m√™me si leur valeur est destin√©e √† repr√©senter un type diff√©rent. Si vous souhaitez utiliser vos variables d'environnement comme un type diff√©rent au moment de l'ex√©cution, vous pouvez utiliser la fonction `coerce` de Zod pour convertir la cha√Æne vers le type souhait√©. Une erreur sera lanc√©e si la conversion √©choue.

Ajoutez les variables √† votre fichier `.env` :

```
SOME_NUMBER=123
SOME_BOOLEAN=true
```

Ensuite, validez-les dans `env.js` :

```ts
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    SOME_NUMBER: z.coerce.number(),
    SOME_BOOLEAN: z.coerce.boolean(),
  },
  // ...
  runtimeEnv: {
    SOME_NUMBER: process.env.SOME_NUMBER,
    SOME_BOOLEAN: process.env.SOME_BOOLEAN,
  },
});
```
