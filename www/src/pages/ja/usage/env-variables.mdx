---
title: ç’°å¢ƒå¤‰æ•°
description: Create T3 Appã‚’å§‹ã‚ã‚‹ã«ã‚ãŸã£ã¦
layout: ../../../layouts/docs.astro
lang: ja
isMdx: true
---

import Callout from "../../../components/docs/callout.tsx";

Create T3 App uses [Zod](https://github.com/colinhacks/zod) for validating your environment variables at runtime _and_ buildtime by providing some additional logic in `src/env.mjs`.

Create T3 App ã¯ã€[Zod](https://github.com/colinhacks/zod)ã‚’ä½¿ç”¨ã—ã¦ã€`src/env.mjs`ã«ã„ãã¤ã‹ã®è¿½åŠ ãƒ­ã‚¸ãƒƒã‚¯ã‚’æä¾›ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€å®Ÿè¡Œæ™‚*ãŠã‚ˆã³*æ§‹ç¯‰æ™‚ã«ç’°å¢ƒå¤‰æ•°ã®æ¤œè¨¼ã‚’è¡Œã†ã€‚

## env.mjs

_TLDR; If you want to add a new environment variable, you must add it to both your `.env` as well as define the validator in `src/env.mjs`._

This file is split into two parts - the schema and object destructuring as well as the validation logic. The validation logic should not need to be touched.

## env.mjs

_TLDR; ç’°å¢ƒå¤‰æ•°ã‚’è¿½åŠ ã™ã‚‹å ´åˆã¯ã€`.env`ã«è¿½åŠ ã™ã‚‹ã¨ã¨ã‚‚ã«ã€`src/env.mjs`ã«ãƒãƒªãƒ‡ãƒ¼ã‚¿ãƒ¼ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚_

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ã‚¹ã‚­ãƒ¼ãƒã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†æ§‹ç¯‰ã¨ã€æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã® 2 ã¤ã®éƒ¨åˆ†ã«åˆ†ã‹ã‚Œã¦ã„ã¾ã™ã€‚æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã¯è§¦ã‚‹å¿…è¦ãŒãªã„ã¯ãšã§ã™ã€‚

```ts:env.mjs
const server = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]),
});

const client = z.object({
  // NEXT_PUBLIC_CLIENTVAR: z.string(),
});

const processEnv = {
  NODE_ENV: process.env.NODE_ENV,
  // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,
};
```

### Server Schema

Define your server-side environment variables schema here.

### ã‚µãƒ¼ãƒãƒ¼ã‚¹ã‚­ãƒ¼ãƒ

ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ç’°å¢ƒå¤‰æ•°ã‚¹ã‚­ãƒ¼ãƒã‚’ã“ã“ã§å®šç¾©ã—ã¾ã™ã€‚

<Callout type="warning">
  Make sure you do not prefix keys here with `NEXT_PUBLIC` in order not to leak
  important secrets to the client.
</Callout>

### Client Schema

Define your client-side environment variables schema here.

To expose them to the client you need to prefix them with `NEXT_PUBLIC`. Validation will fail if you don't to help you detect invalid configuration.

### ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¹ã‚­ãƒ¼ãƒ

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®ç’°å¢ƒå¤‰æ•°ã®ã‚¹ã‚­ãƒ¼ãƒã‚’ã“ã“ã§å®šç¾©ã—ã¾ã™ã€‚

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å…¬é–‹ã™ã‚‹ã«ã¯ã€ãã®å‰ã« `NEXT_PUBLIC` ã‚’ä»˜ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç„¡åŠ¹ãªè¨­å®šã‚’æ¤œå‡ºã™ã‚‹ã®ã«å½¹ç«‹ã¤ã‚ˆã†ã«ã€ãã†ã—ãªã„ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤±æ•—ã—ã¾ã™ã€‚

### processEnv Object

Destruct the `process.env` here.

We need a JavaScript object that we can parse our Zod-schemas with and due to the way Next.js handles environment variables, you can't destruct `process.env` like a regular object, so we need to do it manually.

TypeScript will help you make sure that you have destructed all the keys from both schemas.

### processEnv ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

ã“ã“ã§ `process.env` ã‚’åˆ†è§£ã™ã‚‹ã€‚

Next.js ã§ã¯ç’°å¢ƒå¤‰æ•°ã‚’æ‰±ã†éš›ã«ã€é€šå¸¸ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚ˆã†ã« `process.env` ã‚’åˆ†è§£ã™ã‚‹ã“ã¨ãŒã§ããªã„ã®ã§ã€æ‰‹å‹•ã§è¡Œã†å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

TypeScript ã¯ã€ä¸¡æ–¹ã®ã‚¹ã‚­ãƒ¼ãƒã‹ã‚‰ã™ã¹ã¦ã®ã‚­ãƒ¼ã‚’åˆ†è§£ã—ãŸã“ã¨ã‚’ç¢ºèªã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚

```ts
// âŒ This doesn't work, we need to destruct it manually
const schema = z.object({
  NEXT_PUBLIC_WS_KEY: z.string(),
});

const validated = schema.parse(process.env);
```

### Validation Logic

### ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ­ã‚¸ãƒƒã‚¯

_For the interested reader:_

_èˆˆå‘³ã®ã‚ã‚‹èª­è€…ã®ãŸã‚ã«:_

<details>
<summary>é«˜åº¦ãªè©±é¡Œ: ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚¸ãƒƒã‚¯</summary>

Depending on the environment (server or client) we validate either both or just the client schema. This means that even though the server environment variables will be undefined, they won't trigger the validation to fail - meaning we can have a single entrypoint for our environment variables.

ç’°å¢ƒï¼ˆã‚µãƒ¼ãƒãƒ¼ã¾ãŸã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼‰ã«å¿œã˜ã¦ã€ä¸¡æ–¹ã®ã‚¹ã‚­ãƒ¼ãƒã‚’æ¤œè¨¼ã™ã‚‹ã‹ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚¹ã‚­ãƒ¼ãƒã ã‘ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ã‚µãƒ¼ãƒãƒ¼ã®ç’°å¢ƒå¤‰æ•°ãŒæœªå®šç¾©ã§ã‚ã£ã¦ã‚‚ã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¤±æ•—ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€ç’°å¢ƒå¤‰æ•°ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’ 1 ã¤ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```ts
// src/env.mjs

const isServer = typeof window === "undefined";

const merged = server.merge(client);
const parsed = isServer
  ? merged.safeParse(processEnv) // <-- on server, validate all
  : client.safeParse(processEnv); // <-- on client, validate only client

if (parsed.success === false) {
  console.error(
    "âŒ Invalid environment variables:\n",
    ...formatErrors(parsed.error.format()),
  );
  throw new Error("Invalid environment variables");
}
```

Then, we use a proxy object to throw errors if you try to access a server-side environment variable on the client.

ãã—ã¦ã€ãƒ—ãƒ­ã‚­ã‚·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ã£ã¦ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ç’°å¢ƒå¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

```ts
// src/env.mjs

// proxy allows us to remap the getters
export const env = new Proxy(parsed.data, {
  get(target, prop) {
    if (typeof prop !== "string") return undefined;
    // on the client we only allow NEXT_PUBLIC_ variables
    if (!isServer && !prop.startsWith("NEXT_PUBLIC_"))
      throw new Error(
        "âŒ Attempted to access serverside environment variable on the client",
      );
    return target[prop]; // <-- otherwise, return the value
  },
});
```

</details>

## Using Environment Variables

When you want to use your environment variables, you can import them from `env.mjs` and use them as you would normally do. If you import this on the client and try accessing a server-side environment variable, you will get a runtime error.

## ç’°å¢ƒå¤‰æ•°ã®ä½¿ç”¨

ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ã„ãŸã„ã¨ãã¯ã€`env.mjs`ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã€é€šå¸¸ã¨åŒã˜ã‚ˆã†ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã€ã‚µãƒ¼ãƒãƒ¼å´ã®ç’°å¢ƒå¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚

```ts:pages/api/hello.ts
import { env } from "../../env.mjs";

// `env` is fully typesafe and provides autocompletion
const dbUrl = env.DATABASE_URL;
```

```ts:pages/index.tsx
import { env } from "../env.mjs";

// âŒ This will throw a runtime error
const dbUrl = env.DATABASE_URL;

// âœ… This is fine
const wsKey = env.NEXT_PUBLIC_WS_KEY;
```

## .env.example

Since the default `.env` file is not committed to version control, we have also included a `.env.example` file, in which you can optionally keep a copy of your `.env` file with any secrets removed. This is not required, but we recommend keeping the example up to date to make it as easy as possible for contributors to get started with their environment.

Some frameworks and build tools, like Next.js, suggest that you store secrets in a `.env.local` file and commit `.env` files to your project. This is not recommended, as it could make it easy to accidentally commit secrets to your project. Instead, we recommend that you store secrets in `.env`, keep your `.env` file in your `.gitignore` and only commit `.env.example` files to your project.

## .env.example

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã«ã‚³ãƒŸãƒƒãƒˆã•ã‚Œãªã„ã®ã§ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ `.env.example` ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ç”¨æ„ã—ã¾ã—ãŸã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã€ç§˜å¯†æƒ…å ±ãŒå‰Šé™¤ã•ã‚ŒãŸ `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ”ãƒ¼ã‚’ä¿å­˜ã—ã¦ãŠãã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯å¿…é ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€ã‚³ãƒ³ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚¿ãƒ¼ãŒè‡ªåˆ†ã®ç’°å¢ƒã‚’ä½¿ã„å§‹ã‚ã‚‹ã®ã‚’ã§ãã‚‹ã ã‘ç°¡å˜ã«ã™ã‚‹ãŸã‚ã«ã€example ã‚’æœ€æ–°ã«ä¿ã¤ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

Next.js ã®ã‚ˆã†ãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚„ãƒ“ãƒ«ãƒ‰ãƒ„ãƒ¼ãƒ«ã§ã¯ã€ç§˜å¯†æƒ…å ±ã‚’ `.env.local` ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã—ã€ `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒŸãƒƒãƒˆã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ã“ã‚Œã ã¨èª¤ã£ã¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ç§˜å¯†æƒ…å ±ã‚’ã‚³ãƒŸãƒƒãƒˆã—ã¦ã—ã¾ã†ã‹ã‚‚ã—ã‚Œãªã„ãŸã‚ã€ã‚ã¾ã‚ŠãŠå‹§ã‚ã§ãã¾ã›ã‚“ã€‚ãã®ä»£ã‚ã‚Šã«ã€ç§˜å¯†æƒ…å ±ã‚’ `.env` ã«ä¿å­˜ã—ã€ `.env` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ `.gitignore` ã«ä¿å­˜ã—ã€ `.env.example` ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒŸãƒƒãƒˆã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

## Adding Environment Variables

To ensure your build never completes without the environment variables the project needs, you will need to add new environment variables in **two** locations:

ğŸ“„ `.env`: Enter your environment variable like you would normally do in a `.env` file, i.e. `KEY=VALUE`

ğŸ“„ `env.mjs`: Add the appropriate validation logic for the environment variable by defining a Zod schema, e.g. `KEY: z.string()`, and destruct the environment variable from `process.env` in the `processEnv` object, e.g. `KEY: process.env.KEY`.

Optionally, you can also keep `.env.example` updated:

ğŸ“„ `.env.example`: Enter your environment variable, but be sure to not include the value if it is secret, i.e. `KEY=VALUE` or `KEY=`

## ç’°å¢ƒå¤‰æ•°ã‚’è¿½åŠ ã™ã‚‹

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒå¿…è¦ã¨ã™ã‚‹ç’°å¢ƒå¤‰æ•°ãŒãªã„çŠ¶æ…‹ã§ãƒ“ãƒ«ãƒ‰ãŒå®Œäº†ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã€**2**ç®‡æ‰€ã«æ–°ã—ã„ç’°å¢ƒå¤‰æ•°ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š

ğŸ“„ `.env` ã‚’å…¥åŠ›ã—ã¾ã™ï¼š`.env`ãƒ•ã‚¡ã‚¤ãƒ«ã«é€šå¸¸å…¥åŠ›ã™ã‚‹ã‚ˆã†ã«ã€ç’°å¢ƒå¤‰æ•°ã‚’å…¥åŠ›ã—ã¾ã™ï¼ˆä¾‹ï¼š`KEY=VALUE`ï¼‰ã€‚

ğŸ“„ `env.mjs`ï¼šç’°å¢ƒå¤‰æ•°ã«é©åˆ‡ãªæ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€Zod ã‚¹ã‚­ãƒ¼ãƒã‚’å®šç¾©ã—ã¾ã™ï¼ˆä¾‹ï¼š`KEY: z.string()` ï¼‰ã€‚ãã—ã¦ã€ç’°å¢ƒå¤‰æ•°ã‚’ `process.env` ã‹ã‚‰ `processEnv` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«åˆ†è§£ã—ã¾ã™ï¼ˆä¾‹ï¼š`KEY: process.env.KEY` ï¼‰ã€‚

ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã€`.env.example`ã‚’æ›´æ–°ã—ã¦ãŠãã“ã¨ã‚‚ã§ãã¾ã™ï¼š

ğŸ“„ `.env.example`ï¼šç’°å¢ƒå¤‰æ•°ã‚’å…¥åŠ›ã—ã¾ã™ã€‚ãŸã ã—ã€å€¤ãŒç§˜å¯†ã§ã‚ã‚‹å ´åˆã¯ã€ãã®å€¤ã‚’å«ã‚ãªã„ã‚ˆã†ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

### Example

_I want to add my Twitter API Token as a server-side environment variable_

1. Add the environment variable to `.env`:

### ä¾‹

_ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ç’°å¢ƒå¤‰æ•°ã¨ã—ã¦ã€Twitter API Token ã‚’è¿½åŠ ã—ãŸã„_ã€‚

1. ç’°å¢ƒå¤‰æ•°ã‚’ `.env` ã«è¿½åŠ ã™ã‚‹ï¼š

```
TWITTER_API_TOKEN=1234567890
```

2. Add the environment variable to `env.mjs`:

3. ç’°å¢ƒå¤‰æ•°ã‚’ `env.mjs` ã«è¿½åŠ ã™ã‚‹ï¼š

```ts
export const server = z.object({
  // ...
  TWITTER_API_TOKEN: z.string(),
});

export const processEnv = {
  // ...
  TWITTER_API_TOKEN: process.env.TWITTER_API_TOKEN,
};
```

<Callout type="info">
  An empty string is still a string, so `z.string()` will accept an empty string
  as a valid value. If you want to make sure that the environment variable is
  not empty, you can use `z.string().min(1)`.
</Callout>

<Callout type="info">
  ç©ºæ–‡å­—åˆ—ã¯æ–‡å­—åˆ—ãªã®ã§ã€`z.string()`ã¯ç©ºæ–‡å­—åˆ—ã‚’
  ã‚’æœ‰åŠ¹ãªå€¤ã¨ã—ã¦å—ã‘å…¥ã‚Œã¾ã™ã€‚ã‚‚ã—ã€ç’°å¢ƒå¤‰æ•°ãŒ
  ãŒç©ºã§ã‚ã£ã¦ã¯ãªã‚‰ãªã„å ´åˆã¯ã€`z.string().min(1)`ã®ã‚ˆã†ã«æŒ‡å®šã—ã¾ã™ã€‚
</Callout>

3. _Optional:_ Add the environment variable to `.env.example`, but don't include the token

4. _ã‚ªãƒ—ã‚·ãƒ§ãƒ³:_ ç’°å¢ƒå¤‰æ•°ã‚’ `.env.example` ã«è¿½åŠ ã—ã¾ã™ãŒã€ãƒˆãƒ¼ã‚¯ãƒ³ã¯å«ã‚ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚

```
TWITTER_API_TOKEN=
```
